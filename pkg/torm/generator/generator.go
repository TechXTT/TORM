package generator

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/TechXTT/TORM/pkg/torm/internal/metadata"
)

// formatFile formats the given file using gofmt.
func formatFile(filePath string) error {
	cmd := exec.Command("go", "fmt", filePath)
	return cmd.Run()
}

var modelTemplate = template.Must(template.New("model").
	Funcs(template.FuncMap{
		"hasTime": func(fields []metadata.Field) bool {
			for _, f := range fields {
				if f.Type == "time.Time" {
					return true
				}
			}
			return false
		},
		"hasUUID": func(fields []metadata.Field) bool {
			for _, f := range fields {
				if f.Type == "uuid.UUID" {
					return true
				}
			}
			return false
		},
		"goType": func(t string) string {
			if strings.HasSuffix(t, "[]") {
				return "[]" + strings.TrimSuffix(t, "[]")
			}
			return t
		},
	}).
	Parse(`package models

// Code generated by TORM; DO NOT EDIT.
		
import (
{{- if hasUUID .Fields }}
    "github.com/google/uuid"
{{- end }}
{{- if hasTime .Fields }}
    "time"
{{- end }}
)

type {{ .Name }} struct {
{{- range .Fields }}
    {{ .Name }} {{ goType .Type }}
{{- end }}
}
`))

// Generate reads a Prisma schema and outputs Go client code.
func Generate(schemaPath, outDir string) error {
	data, err := os.ReadFile(schemaPath)
	if err != nil {
		return err
	}
	ast, err := metadata.ParseSchema(data)
	if err != nil {
		return err
	}
	fmt.Printf("Parsed %d entities\n", len(ast.Entities))
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	// generate one file per entity
	for _, ent := range ast.Entities {
		filePath := filepath.Join(outDir, strings.ToLower(ent.Name)+".go")
		f, err := os.Create(filePath)
		if err != nil {
			return err
		}
		defer f.Close()

		if err := modelTemplate.Execute(f, ent); err != nil {
			return err
		}
		if err := f.Close(); err != nil {
			return err
		}

		// format the file
		if err := formatFile(filePath); err != nil {
			return err
		}

		fmt.Printf("Generated model %s\n", filePath)
	}

	return nil
}
