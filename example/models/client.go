package models

// Code generated by TORM; DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
	"sync"

	_ "github.com/lib/pq"
)

// Client wraps a database connection and provides per-model services.
type Client struct {
	dsn  string
	db   *sql.DB
	once sync.Once
	err  error
}

// NewClient reads DSN from prisma/schema.prisma and returns a Client.
func NewClient() *Client {
	data, err := ioutil.ReadFile("prisma/schema.prisma")
	if err != nil {
		panic(fmt.Sprintf("cannot read schema: %v", err))
	}
	re := regexp.MustCompile(`url\s*=\s*(?:env\("([^"]+)"\)|"([^\"]+)")`)
	m := re.FindStringSubmatch(string(data))
	var dsn string
	if m[1] != "" {
		dsn = strings.Trim(os.Getenv(m[1]), "")
	} else {
		dsn = strings.Trim(m[2], "")
	}
	// disable SSL if not set
	if strings.HasPrefix(dsn, "postgres://") && !strings.Contains(dsn, "sslmode=") {
		sep := "?"
		if strings.Contains(dsn, "?") {
			sep = "&"
		}
		dsn += sep + "sslmode=disable"
	}
	return &Client{dsn: dsn}
}

// connect opens the DB once.
func (c *Client) connect() (*sql.DB, error) {
	c.once.Do(func() {
		c.db, c.err = sql.Open("postgres", c.dsn)
		if c.err != nil {
			return
		}
		c.err = c.db.PingContext(context.Background())
	})
	return c.db, c.err
}

// CreatorService provides DB operations for the Creator model.
type CreatorService struct {
	db *sql.DB
}

// CreatorService returns a new service for Creator.
func (c *Client) CreatorService() (*CreatorService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &CreatorService{db: db}, nil
}

// FindUnique retrieves a single Creator by unique filter.
func (svc *CreatorService) FindUnique(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "username", "email", "createdat", "updatedat"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "creator", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Creator or returns an error if not found.
func (svc *CreatorService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Creator not found")
	}
	return rec, nil
}

// FindFirst retrieves the first Creator matching filters.
func (svc *CreatorService) FindFirst(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "username", "email", "createdat", "updatedat"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, append(args)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Creator
	for rows.Next() {
		var m Creator
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// FindFirstOrThrow retrieves the first Creator or errors if none.
func (svc *CreatorService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) (*Creator, error) {
	recs, err := svc.FindFirst(ctx, where, orderBy, skip, take)
	if err != nil {
		return nil, err
	}
	if len(recs) == 0 {
		return nil, fmt.Errorf("no Creator found")
	}
	return recs[0], nil
}

// FindMany retrieves multiple Creator records.
func (svc *CreatorService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Creator, error) {
	return svc.FindFirst(ctx, where, orderBy, skip, take)
}

// Create inserts a new Creator record.
func (svc *CreatorService) Create(ctx context.Context, data map[string]interface{}) (*Creator, error) {
	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "creator", colsList, phList, colsList)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	return &m, nil
}

// Update modifies an existing Creator record.
func (svc *CreatorService) Update(ctx context.Context, where, data map[string]interface{}) (*Creator, error) {
	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	cols := []string{"id", "username", "email", "createdat", "updatedat"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "creator", setClause, whereClause, strings.Join(cols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	return &m, nil
}

// Upsert creates or updates a Creator record in a transaction.
func (svc *CreatorService) Upsert(ctx context.Context, where, createData, updateData map[string]interface{}) (*Creator, error) {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return nil, err
	}
	if rec == nil {
		rec, err = svc.Create(ctx, createData)
	} else {
		rec, err = svc.Update(ctx, where, updateData)
	}
	if err != nil {
		tx.Rollback()
		return nil, err
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return rec, nil
}

// Delete removes a Creator record by unique filter.
func (svc *CreatorService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Creator records matching 'where'.
func (svc *CreatorService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Creator records in a single statement.
func (svc *CreatorService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "creator", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Creator records.
func (svc *CreatorService) UpdateMany(ctx context.Context, where, data map[string]interface{}) (int64, error) {
	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s", "creator", setClause, whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// DeleteMany removes multiple Creator records.
func (svc *CreatorService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Creator.
func (svc *CreatorService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Creator by specified fields and computes aggregates.
func (svc *CreatorService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// PostService provides DB operations for the Post model.
type PostService struct {
	db *sql.DB
}

// PostService returns a new service for Post.
func (c *Client) PostService() (*PostService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &PostService{db: db}, nil
}

// FindUnique retrieves a single Post by unique filter.
func (svc *PostService) FindUnique(ctx context.Context, where map[string]interface{}) (*Post, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "title", "content", "published", "createdat", "updatedat", "authorid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "post", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Post
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Post or returns an error if not found.
func (svc *PostService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Post, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Post not found")
	}
	return rec, nil
}

// FindFirst retrieves the first Post matching filters.
func (svc *PostService) FindFirst(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Post, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "title", "content", "published", "createdat", "updatedat", "authorid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "post")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, append(args)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Post
	for rows.Next() {
		var m Post
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// FindFirstOrThrow retrieves the first Post or errors if none.
func (svc *PostService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) (*Post, error) {
	recs, err := svc.FindFirst(ctx, where, orderBy, skip, take)
	if err != nil {
		return nil, err
	}
	if len(recs) == 0 {
		return nil, fmt.Errorf("no Post found")
	}
	return recs[0], nil
}

// FindMany retrieves multiple Post records.
func (svc *PostService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Post, error) {
	return svc.FindFirst(ctx, where, orderBy, skip, take)
}

// Create inserts a new Post record.
func (svc *PostService) Create(ctx context.Context, data map[string]interface{}) (*Post, error) {
	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "post", colsList, phList, colsList)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Post
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	return &m, nil
}

// Update modifies an existing Post record.
func (svc *PostService) Update(ctx context.Context, where, data map[string]interface{}) (*Post, error) {
	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	cols := []string{"id", "title", "content", "published", "createdat", "updatedat", "authorid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "post", setClause, whereClause, strings.Join(cols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Post
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	return &m, nil
}

// Upsert creates or updates a Post record in a transaction.
func (svc *PostService) Upsert(ctx context.Context, where, createData, updateData map[string]interface{}) (*Post, error) {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return nil, err
	}
	if rec == nil {
		rec, err = svc.Create(ctx, createData)
	} else {
		rec, err = svc.Update(ctx, where, updateData)
	}
	if err != nil {
		tx.Rollback()
		return nil, err
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return rec, nil
}

// Delete removes a Post record by unique filter.
func (svc *PostService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "post", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Post records matching 'where'.
func (svc *PostService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "post")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Post records in a single statement.
func (svc *PostService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "post", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Post records.
func (svc *PostService) UpdateMany(ctx context.Context, where, data map[string]interface{}) (int64, error) {
	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s", "post", setClause, whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// DeleteMany removes multiple Post records.
func (svc *PostService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "post", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Post.
func (svc *PostService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "post")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Post by specified fields and computes aggregates.
func (svc *PostService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "post")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// Helper functions used by services

// buildWhere assembles SQL WHERE clause and args
func buildWhere(where map[string]interface{}) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := 1
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildWhereOffset is like buildWhere but starts binding at offset
func buildWhereOffset(where map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildInsert assembles INSERT columns, placeholders, and args
func buildInsert(data map[string]interface{}) ([]string, []string, []interface{}) {
	var cols []string
	var placeholders []string
	var args []interface{}
	i := 1
	for k, v := range data {
		cols = append(cols, k)
		placeholders = append(placeholders, fmt.Sprintf("$%d", i))
		args = append(args, v)
		i++
	}
	return cols, placeholders, args
}

// buildSet assembles SET clause and args
func buildSet(data map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range data {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, ", "), args
}

// scanDest returns a slice of pointers for scanning into struct fields
func scanDest(m interface{}) []interface{} {
	// leverage reflection or generate this per-model if needed
	return []interface{}{ /* generated per-model field pointers */ }
}
